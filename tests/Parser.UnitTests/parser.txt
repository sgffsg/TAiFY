using Lexer;

namespace Parser;

public abstract class ExpressionValue
{
    public abstract decimal AsNumber();

    public abstract bool AsBoolean();

    public abstract string AsString();
}

public class NumberValue : ExpressionValue
{
    private readonly decimal value;

    public NumberValue(decimal value) => this.value = value;

    public override decimal AsNumber() => value;

    public override bool AsBoolean() => value != 0;

    public override string AsString() => value.ToString();
}

public class BooleanValue : ExpressionValue
{
    private readonly bool value;

    public BooleanValue(bool value) => this.value = value;

    public override decimal AsNumber() => value ? 1 : 0;

    public override bool AsBoolean() => value;

    public override string AsString() => value ? "ХАЙП" : "КРИНЖ";
}

public class StringValue : ExpressionValue
{
    private readonly string value;

    public StringValue(string value) => this.value = value;

    public override decimal AsNumber() => decimal.TryParse(value, out decimal result) ? result : 0;

    public override bool AsBoolean() => !string.IsNullOrEmpty(value);

    public override string AsString() => value;
}

/// <summary>
/// Выполняет синтаксический разбор для языка Vaibik.
/// </summary>
public class Parser
{
    private readonly TokenStream tokens;

    private Parser(string code)
    {
        tokens = new TokenStream(code);
    }

    public static List<ExpressionValue> ExecuteExpr(string expr)
    {
        Parser p = new(expr);
        List<ExpressionValue> result = p.ParseExpressionList();

        if (p.tokens.Peek().Type != TokenType.EOF)
        {
            throw new UnexpectedLexemeException(TokenType.EOF, p.tokens.Peek());
        }

        return result;
    }

    private List<ExpressionValue> ParseExpressionList()
    {
        List<ExpressionValue> values = new List<ExpressionValue> { ParseExpr() };
        while (tokens.Peek().Type == TokenType.Comma)
        {
            tokens.Advance();
            values.Add(ParseExpr());
        }

        return values;
    }

    private ExpressionValue ParseExpr()
    {
        return ParseLogicalOrExpr();
    }

    private ExpressionValue ParseLogicalOrExpr()
    {
        ExpressionValue left = ParseLogicalAndExpr();
        while (tokens.Peek().Type == TokenType.Or)
        {
            tokens.Advance();
            ExpressionValue right = ParseLogicalAndExpr();
            bool result = left.AsBoolean() || right.AsBoolean();
            left = new BooleanValue(result);
        }

        return left;
    }

    private ExpressionValue ParseLogicalAndExpr()
    {
        ExpressionValue left = ParseComparisonExpr();
        while (tokens.Peek().Type == TokenType.And)
        {
            tokens.Advance();
            ExpressionValue right = ParseComparisonExpr();
            bool result = left.AsBoolean() && right.AsBoolean();
            left = new BooleanValue(result);
        }

        return left;
    }

    private ExpressionValue ParseComparisonExpr()
    {
        ExpressionValue left = ParseAdditiveExpr();

        switch (tokens.Peek().Type)
        {
            case TokenType.Equal:
                tokens.Advance();
                ExpressionValue rightEq = ParseAdditiveExpr();
                bool eqResult = left.AsNumber() == rightEq.AsNumber();
                return new BooleanValue(eqResult);

            case TokenType.NotEqual:
                tokens.Advance();
                ExpressionValue rightNe = ParseAdditiveExpr();
                bool neResult = left.AsNumber() != rightNe.AsNumber();
                return new BooleanValue(neResult);

            case TokenType.LessThan:
                tokens.Advance();
                ExpressionValue rightLt = ParseAdditiveExpr();
                bool ltResult = left.AsNumber() < rightLt.AsNumber();
                return new BooleanValue(ltResult);

            case TokenType.GreaterThan:
                tokens.Advance();
                ExpressionValue rightGt = ParseAdditiveExpr();
                bool gtResult = left.AsNumber() > rightGt.AsNumber();
                return new BooleanValue(gtResult);

            case TokenType.LessThanOrEqual:
                tokens.Advance();
                ExpressionValue rightLe = ParseAdditiveExpr();
                bool leResult = left.AsNumber() <= rightLe.AsNumber();
                return new BooleanValue(leResult);

            case TokenType.GreaterThanOrEqual:
                tokens.Advance();
                ExpressionValue rightGe = ParseAdditiveExpr();
                bool geResult = left.AsNumber() >= rightGe.AsNumber();
                return new BooleanValue(geResult);

            default:
                return left;
        }
    }

    private ExpressionValue ParseAdditiveExpr()
    {
        ExpressionValue value = ParseMultiplicativeExpr();
        while (true)
        {
            switch (tokens.Peek().Type)
            {
                case TokenType.Plus:
                    tokens.Advance();
                    ExpressionValue rightPlus = ParseMultiplicativeExpr();
                    decimal sum = value.AsNumber() + rightPlus.AsNumber();
                    value = new NumberValue(sum);
                    break;

                case TokenType.Minus:
                    tokens.Advance();
                    ExpressionValue rightMinus = ParseMultiplicativeExpr();
                    decimal diff = value.AsNumber() - rightMinus.AsNumber();
                    value = new NumberValue(diff);
                    break;

                default:
                    return value;
            }
        }
    }

    private ExpressionValue ParseMultiplicativeExpr()
    {
        ExpressionValue value = ParseUnaryExpr();
        while (true)
        {
            switch (tokens.Peek().Type)
            {
                case TokenType.Multiplication:
                    tokens.Advance();
                    ExpressionValue rightMul = ParseUnaryExpr();
                    decimal product = value.AsNumber() * rightMul.AsNumber();
                    value = new NumberValue(product);
                    break;

                case TokenType.Division:
                    tokens.Advance();
                    ExpressionValue rightDiv = ParseUnaryExpr();
                    decimal divisor = rightDiv.AsNumber();
                    if (divisor == 0)
                    {
                        throw new DivideByZeroException();
                    }

                    decimal quotient = value.AsNumber() / divisor;
                    value = new NumberValue(quotient);
                    break;

                case TokenType.Remainder:
                    tokens.Advance();
                    ExpressionValue rightMod = ParseUnaryExpr();
                    decimal modDivisor = rightMod.AsNumber();
                    if (modDivisor == 0)
                    {
                        throw new DivideByZeroException();
                    }

                    decimal remainder = value.AsNumber() % modDivisor;
                    value = new NumberValue(remainder);
                    break;

                default:
                    return value;
            }
        }
    }

    private ExpressionValue ParseUnaryExpr()
    {
        TokenType type = tokens.Peek().Type;
        if (type == TokenType.Plus || type == TokenType.Minus || type == TokenType.Not)
        {
            tokens.Advance();
            ExpressionValue value = ParseUnaryExpr();

            return type switch
            {
                TokenType.Plus => new NumberValue(+value.AsNumber()),
                TokenType.Minus => new NumberValue(-value.AsNumber()),
                TokenType.Not => new BooleanValue(!value.AsBoolean()),
                _ => value
            };
        }

        return ParsePrimary();
    }

    private ExpressionValue ParsePrimary()
    {
        Token t = tokens.Peek();
        switch (t.Type)
        {
            case TokenType.NumericLiteral:
                return ParseNumericLiteral();

            case TokenType.StringLiteral:
                return ParseStringLiteral();

            case TokenType.Hype:
            case TokenType.Cringe:
                return ParseLogicalLiteral();

            case TokenType.PI:
            case TokenType.EULER:
                return ParseConstant();

            case TokenType.Module:
            case TokenType.Minimum:
            case TokenType.Maximum:
            case TokenType.Pow:
            case TokenType.Sqrt:
            case TokenType.Sinus:
            case TokenType.Cosinus:
            case TokenType.Tangens:
                return ParseFunctionCall();

            case TokenType.Identifier:
                throw new UnexpectedLexemeException(TokenType.NumericLiteral, t);

            case TokenType.OpenParenthesis:
                tokens.Advance();
                ExpressionValue value = ParseExpr();
                Match(TokenType.CloseParenthesis);
                return value;

            default:
                throw new UnexpectedLexemeException(t.Type, t);
        }
    }

    private ExpressionValue ParseNumericLiteral()
    {
        Token t = tokens.Peek();
        if (t.Type == TokenType.NumericLiteral)
        {
            decimal value = t.Value!.ToDecimal();
            tokens.Advance();
            return new NumberValue(value);
        }

        throw new UnexpectedLexemeException(TokenType.NumericLiteral, t);
    }

    private ExpressionValue ParseStringLiteral()
    {
        Token t = tokens.Peek();
        tokens.Advance();
        return new StringValue(t.Value?.ToString() ?? "");
    }

    private ExpressionValue ParseLogicalLiteral()
    {
        Token t = tokens.Peek();
        tokens.Advance();
        return t.Type switch
        {
            TokenType.Hype => new BooleanValue(true),
            TokenType.Cringe => new BooleanValue(false),
            _ => throw new UnexpectedLexemeException(t.Type, t),
        };
    }

    private ExpressionValue ParseConstant()
    {
        Token t = tokens.Peek();
        tokens.Advance();
        return t.Type switch
        {
            TokenType.EULER => new NumberValue(2.7182818284M),
            TokenType.PI => new NumberValue(3.1415926535M),
            _ => throw new UnexpectedLexemeException(t.Type, t),
        };
    }

    private ExpressionValue ParseFunctionCall()
    {
        Token nameToken = tokens.Peek();
        tokens.Advance();
        Match(TokenType.OpenParenthesis);

        List<ExpressionValue> args = new List<ExpressionValue>();
        if (tokens.Peek().Type != TokenType.CloseParenthesis)
        {
            args = ParseExpressionList();
        }

        Match(TokenType.CloseParenthesis);

        List<decimal> numericArgs = args.Select(a => a.AsNumber()).ToList();
        decimal result = BuiltinFunctions.Instance.Invoke(nameToken.Type, numericArgs);
        return new NumberValue(result);
    }

    private void Match(TokenType expected)
    {
        if (tokens.Peek().Type != expected)
        {
            throw new UnexpectedLexemeException(expected, tokens.Peek());
        }

        tokens.Advance();
    }
}