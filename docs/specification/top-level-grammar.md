# Грамматика программы языка Vaibik

## 1. Пример кода

Программа на языке Vaibik состоит из набора функций. Точкой входа является процедура с именем `ПОГНАЛИ`.

```
(ПОЯСНИТЕЛЬНАЯ-БРИГАДА: Глобальная константа)
БАЗА ЦИФЕРКА МАКСИМУМ = 100;

(ПОЯСНИТЕЛЬНАЯ-БРИГАДА: Вспомогательная функция)
ЦИФЕРКА сложить(а: ЦИФЕРКА, б: ЦИФЕРКА) 
ПОЕХАЛИ
    ДРАТУТИ а + б;
ФИНАЛОЧКА

(ПОЯСНИТЕЛЬНАЯ-БРИГАДА: Точка входа)
ПРОКРАСТИНИРУЕМ ПОГНАЛИ() 
ПОЕХАЛИ
    ЦИФЕРКА счетчик = 0;
    ЦИФЕРКА ввод = 0;
    
    ВЫБРОС("Введите число: ");
    ВБРОС(ввод);

    ЕСЛИ (ввод > МАКСИМУМ) ТО
        ВЫБРОС("Слишком много!");
    ИНАЧЕ ПОЕХАЛИ
        счетчик = сложить(ввод, 10);
        ВЫБРОС("Результат: ", счетчик);
    ФИНАЛОЧКА;
ФИНАЛОЧКА
```

## 2. Ключевые особенности и Семантика

### Структура программы

* Программа состоит из последовательности объявлений функций, процедур и глобальных переменных/констант.
* Язык программы регистрозависимый.
* Точка входа: Обязательно наличие процедуры `ПРОКРАСТИНИРУЕМ ПОГНАЛИ()`, с которой начинается выполнение.

### Область видимости

* Блочная видимость: Переменные, объявленные внутри блока `ПОЕХАЛИ ... ФИНАЛОЧКА`, видны только внутри него и во
  вложенных блоках.
* Запрещено объявлять переменную с именем, которое уже используется в текущем или внешнем блоке (в рамках одной
  функции).
* Глобальные переменные: Объявленные вне функций переменные видны везде.

### Типизация и переменные

* Язык статически типизированный.
* Запрещено присваивать переменной типа `ЦИФЕРКА` значение типа `ЦИТАТА` и т.д.
* Переменные должны быть инициализированы при объявлении.
* Операции сложения, умножения, вычитания, деления, сравнения двух значений разрешена только если оба значения имеют
  один тип.

## 3. Архитектурные решения

### 3.1. Ввод и вывод

Для взаимодействия с консолью выбраны специальные инструкции, а не встроенные функции. Это позволяет компилятору
жестко контролировать типы аргументов.

* `ВЫБРОС(...)` — инструкция вывода. Может принимать список аргументов.
* `ВБРОС(...)` — инструкция ввода. Принимает переменные, в которые нужно записать данные.

### 3.2. Виды инструкций

Чтобы исключить бессмысленный код, введено правило: не любое выражение является инструкцией.
Инструкцией может быть только выражение, имеющее побочный эффект:

* Присваивание (`x = 10;`)
* Вызов функции (`foo();`)
  Простое сложение (`5 + 5;`) инструкцией не является и вызовет ошибку компиляции.

### 3.3. Разделитель инструкций

Используется символ **«;»** (точка с запятой).
Это упрощает разбор и позволяет писать несколько инструкций в одну строку, игнорируя переносы строк.

### 3.4. Ветвления 
В конструкции `ЕСЛИ ... ТО ... ИНАЧЕ ...` ветка `ИНАЧЕ` связывается с ближайшим предшествующим `ЕСЛИ`. 
Это решает проблему неоднозначности (dangling else).

## 4. Грамматика EBNF

```
program = { topLevelItem } , EOF ;

topLevelItem 
    = procedureDeclaration 
    | constantDeclaration
    | typedDeclaration 
    ;

constantDeclaration = 
    "БАЗА", typeName, identifier, "=", expression, ";" ;

typedDeclaration = 
    typeName, identifier, ( functionTail | variableTail ) ;

functionTail = 
    "(", [ parameterList ], ")", block ;

variableTail = 
    "=", expression, ";" ;

procedureDeclaration = 
    "ПРОКРАСТИНИРУЕМ", identifier, "(", [ parameterList ], ")", block ;

parameterList = 
    identifier, ":", typeName, { ",", identifier, ":", typeName } ;

block = "ПОЕХАЛИ", { statement }, "ФИНАЛОЧКА" ;

statement 
    = variableDeclaration
    | ifStatement
    | whileStatement
    | forStatement
    | returnStatement
    | breakStatement
    | continueStatement
    | ioStatement
    | block       
    | sideEffectStatement
    | ";"
    ;

variableDeclaration = 
    typeName, identifier, "=", expression, ";" ;

ifStatement = 
    "ЕСЛИ", "(", expression, ")", "ТО", statement, 
    [ "ИНАЧЕ", statement ] ;

whileStatement = 
    "ПОКА", "(", expression, ")", block ;

forStatement = 
    "ЦИКЛ", "(", variableAssignment, ";", expression, ";", variableAssignment, ")", block ;

returnStatement = "ДРАТУТИ", [ expression ], ";" ;

breakStatement = "ХВАТИТ", ";" ;

continueStatement = "ПРОДОЛЖАЕМ", ";" ;

ioStatement 
    = ( "ВЫБРОС", "(", [ argumentList ], ")", ";" )
    | ( "ВБРОС", "(", identifier, { ",", identifier }, ")", ";" )
    ;
    
sideEffectStatement = identifier, ( assignmentTail | callTail ), ";" ;

assignmentTail = "=", expression ;
callTail       = "(", [ argumentList ], ")" ;

variableAssignment = identifier, "=", expression ;
```

