# Сравнение языков программирования C++ и Pascal

## 1. Парадигма

### Pascal следует исключительно императивной парадигме:

- Программа как последовательность команд, изменяющих состояние
- Акцент на процедурах и функциях, оперирующих данными
- Жесткая структура: данные и код строго разделены

### C++ - мультипарадигменный язык программирования:

- **Императивная** - процедурное программирование
- **Объектно-ориентированная** - классы, наследование, инкапсуляция
- **Обобщенное программирование** - шаблоны, метапрограммирование
- **Функциональная** - лямбды, функции высшего порядка
- **Абстракции данных** - перегрузка операторов, пользовательские типы

## 2. Структурное программирование

| Конструкция           | Pascal                | C++                             |
|-----------------------|-----------------------|---------------------------------|
| **Цикл for**          | `for i := 1 to 10 do` | `for (int i = 1; i <= 10; i++)` |
| **Цикл while**        | `while condition do`  | `while (condition)`             |
| **Условный оператор** | `if x > 0 then ...`   | `if (x > 0) { ... }`            |
| **Блок кода**         | `begin ... end`       | `{ ... }`                       |

## 3. Объявление типов

| Тип        | Pascal                            | C++             |
|------------|-----------------------------------|-----------------|
| Переменная | `var x: integer`                  | `int x`         |
| Функция    | `function f(a: integer): boolean` | `bool f(int a)` |
| Процедура  | `procedure  p(a: integer)`        | `void p(int a)` |

## 4. Базовые типы данных

| Тип           | Pascal    | C++                     |
|---------------|-----------|-------------------------|
| Целое число   | `integer` | `int`                   |
| Дробное число | `real`    | `float`, `double`       |
| Символ        | `char`    | `char`                  |
| Логический    | `boolean` | `bool`                  |
| Строка        | `string`  | `char[]`, `std::string` |

## 5. Пользовательские функции

**Pascal** - разделение функций и процедур:

```
function Add(a, b: integer): integer;
begin
  Add := a + b;
end;

procedure Print(msg: string);
begin
  WriteLn(msg);
end;
```

**C++** - единый подход:

```
int add(int a, int b) {
    return a + b;
}

void print(string msg) {
    cout << msg << endl;
}
```

**Передача параметров:**

- Pascal: по значению, по ссылке (`var`)
- C++: по значению, по ссылке (`&`), по указателю (`*`)

## 6. Пользовательские структуры

**Pascal:** `record ... end`

```
type Point = record
    x, y: integer;
end;
```

**C++:** `struct ... {}`

```
struct Point {
    int x, y;
};
```

### 7. Работа со строками

**Pascal:**

* Есть встроенный тип `string`
* Строки фиксированной длины;
* Операции: + (сложение), = (сравнение)
* Индексация символов с 1

**C++:**

* Строки это `char[]` или `std::string`
* Строки заканчиваются нулевым символом `\0`
* Индексация символов с 0

### 8. Работа с массивом

**Pascal:**

* Размер массива известен при компиляции
* Границы указываются явно: `array[1..10] of integer`
* Индексация может начинаться с любого числа
* Есть проверка границ

**C++:**

* Размер может быть неизвестен до выполнения
* Границы: `int arr[10] (от 0 до 9)`
* Индексация всегда с 0
* Нет проверки границ

### 9. Работа со списками

**Pascal:** Классический Pascal не имеет списков, но в современных диалектах есть встроенный класс TList
**C++:** Класс в библиотеке std под названием list

### 10. Управление памятью

**Pascal:**

* Автоматическое управление для обычных переменных;
* Для динамической памяти есть `New()` и `Dispose()`

**C++:**

* Автоматическое управление для обычных переменных;
* Динамическая память выделяется через new, освобождается через delete
* Умные указатели `(unique_ptr, shared_ptr)` для автоматического управления

### 11. Обработка ошибок

**Pascal:**

* Используется `try/except` для перехвата ошибок
* `try/finally` для гарантированного выполнения кода
* Возврат кодов ошибок через результат функции

**C++:**

* Используется `try/catch` для перехвата ошибок
* Ошибки бросаются через `throw`
* Возврат кодов ошибок через результат функции

### 12. Операторы

| Категория          | Pascal                           | C++                     |
|--------------------|----------------------------------|-------------------------|
| **Присваивание**   | `:=`                             | `=`                     |
| **Сравнение**      | `=`, `<>`                        | `==`, `!=`              |
| **Логические**     | `and`, `or`, `not`               | `&&`, `\|\|`, `!`       |
| **Арифметические** | `+`, `-`, `*`, `/`, `div`, `mod` | `+`, `-`, `*`, `/`, `%` |

### Вывод

**Лексический анализ:** Разные ключевые слова и операторы (`begin/end` vs `{}`, `:=` vs `=`, `=` vs `==`)

**Синтаксический анализ:**
- Разная грамматика объявлений (тип после идентификатора в Pascal, тип перед идентификатором в C++)
- Разные структуры блоков и областей видимости
- В C++ сложнее из-за перегрузки операторов и шаблонов

**Семантический анализ:**
- Разная система типов (простая в Pascal, сложная с шаблонами в C++)
- Разные правила приведения типов (строгие в Pascal, гибкие в C++)
- В C++ требуется разрешение перегрузки функций

**Генерация промежуточного кода:** Разные модели памяти (автоматическая в Pascal, ручное управление в C++) и вызова функций

Pascal проще для учебного компилятора благодаря строгой структуре и минимализму конструкций. C++ требует обработки сложных выражений, указателей и контекстно-зависимого анализа, что демонстрирует реальные сложности промышленных языков.