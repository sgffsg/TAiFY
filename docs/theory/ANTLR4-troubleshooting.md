# Потенциальные проблемы грамматик и их решение средствами ANTLR4

1. Учёт приоритета операторов
    
    Проблема: Наивная грамматика не отражает приоритет операторов, что приводит к некорректному дереву разбора. Выражение 1 + 2 * 3 может быть разобрано как (1 + 2) * 3

    Решение в ANTLR4: Иерархия правил, где каждому уровню приоритета соответствует свое правило

    ```antlr
    expr : expr '+' term 
        | expr '-' term
        | term
        ;
    term : term '*' factor
        | term '/' factor
        | factor
        ;
    factor : INT
        | '(' expr ')'
        ;
    ```

    Пояснение: Правило factor (высший приоритет) обрабатывает числа и скобки, term — операции * | /, expr — операции + | -

2. Левая рекурсия

    Проблема: Леворекурсивные правила вызывают бесконечную рекурсию в нисходящих парсерах

    Граматика:
    
    ```
    expr : expr '+' INT
     | INT
     ;
    ```

    Решение в ANTLR4: Парсер явно поддерживает левую рекурсию. Грамматика выше будет работать без изменений
    
3. Левоассоциативные операции

    Проблема: Праворекурсивная грамматика приводит к правой ассоциативности.
    Выражение 5 - 3 - 1 разбирается как (5 - (3 - 1)), что равно 3, а не 1.

    Грамматика: 

    ```
    expr : INT '-' expr
     | INT
     ;
    ```

    Решение в ANTLR4: Леворекурсивное правило автоматически обеспечивает левую ассоциативность.

4. Правоассоциативные операторы

    Проблема: Леворекурсивное правило для оператора ^ приведет к левой ассоциативности: (2 ^ 3) ^ 2 = 64, а не 2 ^ (3 ^ 2) = 512.

    Решение в ANTLR4: Праворекурсивное правило для целевого оператора

    ```
    power : primary ('^' power)? ;
    expr  : power
        | expr '+' expr
        | expr '*' expr
        ;
    ```

5. Неоднозначность правил

    Проблема: Конфликт между правилами для переменной и вызова функции без аргументов

    Проблемная граматика:
    ```
    expression : ID
           | ID '(' ')'
           ;
    ```

    Для токена foo парсер всегда выберет Var, так как это правило подходит первым

    Решение в ANTLR4: Расположить более специфичное правило первым
        ```
        expression : ID '(' ')'       # CallNoArgs
           | ID               # Var
           ;
        ```

6. Конфликт if-else (dangling else)

    Проблема: Неоднозначность if (a) if (b) c; else d;

    Решение: ANTLR4 по умолчанию разрешает эту неоднозначность, всегда привязывая else к ближайшему if. Если проблема возникает, проверьте структуру правил. Пример грамматики:
    ```
    stat: 'if' expr 'then' stat ('else' stat)? | ... ;
    ```
