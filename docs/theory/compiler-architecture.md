## Компилятор
*Компилятор* - программа, переводящая написанный на языке программирования текст в набор машинных кодов, байткод виртуальной машины или промежуточное представление, которое может быть исполнено машиной или интерпретатором.

## Виды компиляторов
* *Векторизующий* Базируется на трансляторе, транслирующем исходный код в машинный код компьютеров, оснащённых векторным процессором.
* *Гибкий* Сконструирован по модульному принципу, управляется таблицами и запрограммирован на языке высокого уровня или реализован с помощью компилятора компиляторов.
* *Инкрементальный* Сконструирован по модульному принципу, управляется таблицами и запрограммирован на языке высокого уровня или реализован с помощью компилятора компиляторов.
* *Интерпретирующий (пошаговый)* Последовательно выполняет независимую компиляцию каждого отдельного оператора (команды) исходной программы.
* *Компилятор компиляторов* Транслятор, воспринимающий формальное описание языка программирования и генерирующий компилятор для этого языка.
* *Отладочный* Устраняет отдельные виды синтаксических ошибок.
* *Резидентный* Постоянно находится в оперативной памяти и доступен для повторного использования многими задачами.
* *Самокомпилируемый* Написан на том же языке программирования, с которого осуществляется трансляция.
* *Универсальный* Основан на формальном описании синтаксиса и семантики входного языка. Составными частями такого компилятора являются: ядро, синтаксический и семантический загрузчики.

## Структура комплятора
![structure](https://www.kv.by/data/software/2008/2008370901.gif) 

## Компилятор и интерпритатор - Различия

1. Время выполнения
  * Компиляторы обычно требуют больше времени на начальном этапе, так как они переводят весь исходный код в машинный код перед выполнением. Однако после компиляции программа выполняется быстрее, так как машинный код уже готов к исполнению. Это особенно важно для крупных проектов, где время выполнения играет ключевую роль.
  * Интерпретаторы, с другой стороны, начинают выполнение кода сразу, но могут работать медленнее, так как анализ и выполнение происходят одновременно. Это может быть полезно для небольших скриптов и задач, где важна скорость разработки, а не выполнения.
2. Ошибки
  * Компиляторы обнаруживают синтаксические и семантические ошибки на этапе компиляции. Это означает, что вы получите все ошибки сразу после попытки скомпилировать программу. Это позволяет исправить все ошибки до начала выполнения программы, что снижает вероятность возникновения ошибок во время работы.
  * Интерпретаторы обнаруживают ошибки во время выполнения кода. Это может быть полезно для быстрого тестирования и отладки, но ошибки могут возникать в неожиданных местах во время работы программы. Например, ошибка может проявиться только при выполнении определенного условия, что усложняет ее обнаружение и исправление.
3. Платформенная независимость
  * Компилированные программы обычно зависят от платформы, для которой они были скомпилированы. Например, исполняемый файл, созданный для Windows, не будет работать на Linux без перекомпиляции. Это требует наличия компилятора для каждой целевой платформы и может усложнить процесс разработки.
  * Интерпретируемые языки часто более платформенно независимы, так как интерпретатор может быть реализован для различных операционных систем. Например, интерпретатор Python доступен для Windows, macOS и Linux, что позволяет запускать один и тот же код на разных платформах без изменений.
4. Промежуточный код
  * Некоторые компиляторы, такие как Java-компилятор, генерируют промежуточный код (байт-код), который затем выполняется виртуальной машиной (JVM). Это позволяет достичь некоторой степени платформенной независимости. Промежуточный код может быть выполнен на любой платформе, для которой существует виртуальная машина, что упрощает переносимость программ.
  * Интерпретаторы обычно не создают промежуточный код, хотя есть исключения, такие как интерпретаторы, которые используют байт-код (например, Python). В таких случаях интерпретатор выполняет байт-код, что может улучшить производительность и переносимость.
5. Удобство отладки
  * Компиляторы предоставляют более детальную информацию об ошибках на этапе компиляции, что упрощает процесс отладки. Вы можете использовать отладчики и профилировщики для анализа производительности и выявления узких мест в коде.
  * Интерпретаторы позволяют быстро вносить изменения и тестировать их, что делает процесс отладки более интерактивным. Вы можете использовать интерактивные среды разработки (IDE) и REPL (Read-Eval-Print Loop) для быстрого тестирования и отладки кода.

## Преимущества компилятора перед интерпретатором
1. Производительность:
  * Скомпилированная программа выполняется быстрее, так как машинный код запускается напрямую, без этапа интерпретации кода.
2. Автономность:
  * Скомпилированная программа не зависит от наличия компилятора или языка на машине конечного пользователя.
3. Безопасность:
  * Итоговый код трудно изменить или восстановить в исходный код, что усложняет реверс-инжиниринг, улучшая защиту от копирования.
4. Детекцирование ошибок:
  * Компилятор позволяет обнаружить многие ошибки до запуска программы.  

## Компиляторы в машинный код
*Компиляторы в машинный код* — это программы, которые переводят исходный код, написанный на языке программирования высокого уровня, в машинный код, который может быть непосредственно выполнен процессором компьютера. 
*Машинный код* — это низкоуровневая последовательность инструкций, специфичная для архитектуры процессора.

## Компиляторы в байт-код виртуальной машины
*Компиляторы в байткод виртуальной машины* - переводят исходный код на языке высокого уровня в байткод — промежуточный формат, который выполняется виртуальной машиной (VM). 
*Байткод* — это компактное представление программы, которое может быть интерпретировано или преобразовано в машинный код во время выполнения (JIT-компиляция).

## Сравнение Компиляторы в машинный код и байт-код виртуальной машины

| Характеристика               | Компиляторы в машинный код  | Компиляторы в байткод                   |
|------------------------------|-----------------------------|-----------------------------------------|
| Производительность           | Высокая                     | Меньшая, зависит от VM                  |
| Платформенная зависимость    | Высокая                     | Низкая                                  |
| Переносимость                | Низкая                      | Высокая                                 |
| Сложность разработки         | Высокая                     | Умеренная                               |
| Примеры                      | GCC, Clang, MSVC            | JVM, CLR, Python VM, BEAM               |


## Диаграмма

flowchart TD
    A[Логический анализ] --> B[Синтаксический анализ]
    B --> C[Семантический анализ]
    C --> D[Генерация промежуточного кода]
    D --> E[Оптимизация кода]
    E --> F[Генерация машинного кода]
    F --> G[Результат]
    
    B -- Поток токенов --> C
    C -- AST<br>(абстрактное синтаксическое дерево) --> D
    D -- IR<br>(промежуточное представление) --> E
    E -- Оптимизированный код --> F
    F -- Машинный код --> G


